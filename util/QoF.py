"""
__author__ = "Mohammed Aldosari"
__date__ = 2/22/24
__version__ = "1.0"
__license__ = "MIT style license file"
"""

import datetime
from typing import Tuple
import numpy as np
import pandas as pd
from util.tools import save_results

"""
QoF: 
    A module for evaulating the quality/goodness of fit
    Supports both symmetric and asymmetric metrics

Functions
----------
smape: 
    def smape(y: np.ndarray, y_pred: np.ndarray) -> float:

mae:
    def mae(y: np.ndarray, y_pred: np.ndarray) -> float:

sst:
    def sst(y: np.ndarray) - > float:

sse:
    def sse(y: np.ndarray, y_pred: np.ndarray) -> float:

r2:
    def r2(y: np.ndarray, y_pred: np.ndarray) -> float:

mse:
    def mse(y: np.ndarray, y_pred: np.ndarray) -> float:

rmse:
    def rmse(y: np.ndarray, y_pred: np.ndarray) -> float:

rae:
    def rae(y: np.ndarray, y_pred: np.ndarray) -> float:
"""


def smape(y: np.ndarray, y_pred: np.ndarray) -> float:
    """
    A function to calculate the symmetric mean absolute percentage error (sMAPE).

    Arguments
    ----------
    y: np.ndarray
        the response data
    y_pred: np.ndarray
        the predicted/forecasted outputs

    Returned Values
    ----------
    smape : float
    """

    return 200 * np.sum(np.abs(y - y_pred) / (np.abs(y) + np.abs(y_pred))) / len(y)


def mae(y: np.ndarray, y_pred: np.ndarray) -> float:
    """
    A function to calculate the mean absolute error (MAE).

    Arguments
    ----------
    y: np.ndarray
        the response data
    y_pred: np.ndarray
        the predicted/forecasted outputs

    Returned Values
    ----------
    mae : float
    """

    return np.sum(np.abs(y - y_pred)) / len(y)


def sst(y: np.ndarray) -> float:
    """
    A function to calculate the sum of squares total (SST).

    Arguments
    ----------
    y: np.ndarray
        the response data

    Returned Values
    ----------
    sst : float
    """

    return np.sum((y - np.mean(y)) ** 2)


def sse(y: np.ndarray, y_pred: np.ndarray) -> float:
    """
    A function to calculate the sum of squared errors (SSE).

    Arguments
    ----------
    y: np.ndarray
        the response data
    y_pred: np.ndarray
        the predicted/forecasted outputs

    Returned Values
    ----------
    sse : float
    """

    return np.sum((y - y_pred) ** 2)


def r2(y: np.ndarray, y_pred: np.ndarray) -> float:
    """
    A function to calculate R squared (r2).

    Arguments
    ----------
    y: np.ndarray
        the response data
    y_pred: np.ndarray
        the predicted/forecasted outputs

    Returned Values
    ----------
    r2 : float
    """

    return 1 - sse(y, y_pred) / sst(y)


def mse(y: np.ndarray, y_pred: np.ndarray) -> float:
    """
    A function to calculate mean squared error (MSE).

    Arguments
    ----------
    y: np.ndarray
        the response data
    y_pred: np.ndarray
        the predicted/forecasted outputs

    Returned Values
    ----------
    mse : float
    """

    return sse(y, y_pred) / len(y)


def rmse(y: np.ndarray, y_pred: np.ndarray) -> float:
    """
    A function to calculate root mean squared error (RMSE).

    Arguments
    ----------
    y: np.ndarray
        the response data
    y_pred: np.ndarray
        the predicted/forecasted outputs

    Returned Values
    ----------
    rmse : float
    """

    return np.sqrt(mse(y, y_pred))


def rae(y: np.ndarray, y_pred: np.ndarray) -> float:
    """
    A function to calculate relative absolute error (RAE).

    Arguments
    ----------
    y: np.ndarray
        the response data
    y_pred: np.ndarray
        the predicted/forecasted outputs

    Returned Values
    ----------
    rae : float
    """

    y_mean = np.mean(y)
    squared_error_num = np.sum(np.abs(y - y_pred))
    squared_error_den = np.sum(np.abs(y - y_mean))
    rae_loss = squared_error_num / squared_error_den
    return rae_loss

def get_metrics(actual, forecasts, args) -> Tuple[int, float, float, float]:
    """
    A function used to calculate and display the metrics assessing the forecasting abilities of a given model.
    I can be extended to have more metrics based on requirements.

    Arguments
    ----------
    actual: ndarray[float]
        the actual values generated by a given model.
    forecasts: ndarray[float]
        the forecasts are generated by the same model.
    args: dict
        a dictionary containing all configuration parameters (used for calculating the metrics).
        serves as an easy way to access the configuration parameters.

    Returned Values
    ----------
    len(actual) : int
    mse_ : float
    mae_ : float
    smape : float
    """

    y = actual.flatten()
    y_pred = forecasts.flatten()
    mse_ = mse(y, y_pred)
    mae_ = mae(y, y_pred)
    smape_ = smape(y, y_pred)
    return len(actual), mse_, mae_, smape_

def diagnose(self, forecasts, forecasts_original) -> None:
    results = pd.DataFrame(columns=["mse_normalized", "mae_normalized", "smape_original"])
    for h in self.args.horizons:
        ignore = -(h - 1) if h > 1 else None
        if self.train_size is None:
            start_index = self.args.seq_len + (h - 1)
        else:
            start_index = self.train_size
        actual = self.data.iloc[start_index:-(self.args.max_horizon - 1), 1:].values
        actual_original = self.data_.iloc[start_index:-(self.args.max_horizon - 1), 1:].values
        if self.train_size is None:
            start_index = 0
            end_index = ignore
        else:
            start_index = self.max_horizon - (h - 1)
            end_index = self.max_horizon - (h - 1) + len(self.test_data)
        N, mse_normalized, mae_normalized, smape_normalized = get_metrics(
            actual, forecasts[start_index:end_index, self.target_int, h - 1], self.args)
        N, mse_original, mae_original, smape_original = get_metrics(
            actual_original, forecasts_original[start_index:end_index, self.target_int, h - 1], self.args)
        values = [mse_normalized, mae_normalized, smape_original]
        new_row = pd.DataFrame([values], columns=results.columns)
        results = pd.concat([results, new_row], ignore_index=True)
    results.loc[len(results)] = results.mean()
    results = results.round(3)
    results = results.reset_index(drop=True)
    results.index = self.args.horizons + ['Avg.']
    print(results)
    today = str(datetime.datetime.today().strftime('%Y-%m-%d'))
    save_results(self, str('results/results '+today+'.csv'), results)
